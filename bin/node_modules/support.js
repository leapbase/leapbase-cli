'use strict';
const debug = require('debug')('support');
const fs = require('fs')
const { move, remove } = require('fs-extra');
const path = require('path');
const { promisify } = require('util');
const axios = require('axios');
const unzip = require('unzipper');
const decompress = require('decompress');

// convert semantic version string to number
// 3.11.0 => 3 * 1000000 + 11 * 1000 + 0
// 3.* => 3 * 1000000 + 999 * 1000 
exports.getSemanticVersionInNumber = function(versionText) {
  let result = 0;
  let versions = versionText.split('.');
  for (var i = 0; i < 3; i++) {
    let value = 0;
    try {
      value = parseInt(versions[i]);
    } catch (e) {
      value = 999;
    }
    value = isNaN(value) ? 999 : value;
    result = result + value * Math.pow(1000, (2-i)); 
  }
  return result;
};

exports.isLeapbaseFolder = async function(path) {
  if (!fs.existsSync(`package.json`)) {
    return false;
  }
  if (!fs.existsSync(`bin/create_extension_symlinks`)) {
    return false;
  }
  return true;
};

exports.getLastestRelease = async function(githubUsername, githubProjectName) {
  let zipUrl = '';
  var releaseUrl = `https://api.github.com/repos/${githubUsername}/${githubProjectName}/releases/latest`;
  try {
    const response = await axios.get(releaseUrl);
    zipUrl = response.data && response.data.zipball_url || '';
  } catch (error) {
    console.error(error);
  }
  return zipUrl;
};

exports.downloadUnzip = async function(url, dest) {
  const response = await axios({
    url: url,
    method: 'GET',
    responseType: 'stream'
  });
  const stream = response.data.pipe(unzip.Extract({ path:dest }));
  return new Promise((resolve, reject) => {
    stream.on('close', () => resolve(dest));
    stream.on('error', () => reject);
  });
};

exports.downloadFile = async function(url, filename) {
  const response = await axios({
    url: url,
    method: 'GET',
    responseType: 'stream'
  });
  const writeStream = fs.createWriteStream(filename);
  response.data.pipe(writeStream);
  return new Promise((resolve, reject) => {
    writeStream.on('close', () => resolve(filename));
    writeStream.on('error', () => reject);
  });
};

exports.decompress = async function(filename, extractFolder) {
  await decompress(filename, extractFolder);
  return extractFolder;
};

// find subfolder starting with given prefix value
exports.getSubFolders = async function(path, prefix) {
  let folders = fs.readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
  if (prefix) {
    const regex = new RegExp('^' + prefix);
    folders = folders.filter(name => name.match(regex))
  }
  return folders
};

exports.runShellCommand = async function(command) {
  const exec = promisify(require('child_process').exec);
    const { stdout, stderr } = await exec(command);
    if (stderr) {
      console.error(`error: ${stderr}`);
    }
    return stdout;
};

// merge sourceRes into targetRes, then retrun targetRes
exports.mergeResource = async function(sourceRes, targetRes) {
  sourceRes = sourceRes || {};
  targetRes = targetRes || {};
  for (var key in sourceRes) {
    let sourceResValue = sourceRes[key] || '';
    let targetResValue = targetRes[key] || '';
    if (!targetResValue) {
      targetRes[key] = sourceResValue;
    } else {
      // merge sourceRes if source version is higher
      let sourceResVerValue = exports.getSemanticVersionInNumber(sourceResValue);
      let targetResVerValue = exports.getSemanticVersionInNumber(targetResValue);
      if (sourceResVerValue > targetResVerValue) {
        targetRes[key] = sourceResValue;
      }
    }
  }
  return targetRes;
};

exports.mergeExtensionResource = async function(extensionFolder) {
  let extensionResFilename = `${extensionFolder}/package.json`;
  let extensionResContent = fs.readFileSync(extensionResFilename);
  let extensionRes = JSON.parse(extensionResContent);
  let leapbaseResFilename = `./package.json`;
  let leapbaseResContent = fs.readFileSync(leapbaseResFilename);
  let leapbaseRes = JSON.parse(leapbaseResContent);
  // check attributes of interest for merging
  let attributes = ['dependencies', 'devDependencies'];
  for (var i = 0; i < attributes.length; i++) {
    let attribute = attributes[i];
    let extensionResAttribute = extensionRes[attribute];
    let leapbaseResAttribute = leapbaseRes[attribute];
    if (extensionResAttribute && leapbaseResAttribute) {
      leapbaseRes[attribute] = await exports.mergeResource(extensionResAttribute, leapbaseResAttribute);
    }
  }
  if ( JSON.stringify(leapbaseRes, null, 2) !== leapbaseResContent) {
    // console.log('>>> write to leapbaseRes:', leapbaseRes); 
    fs.writeFileSync(leapbaseResFilename, JSON.stringify(leapbaseRes, null, 2));
  }
  return true;
};

exports.createProject = async function(projectName, downloadUrl) {
  let githubUsername = 'leapbase';
  let githubProjectName = 'leapbase';

  if (fs.existsSync(projectName)) {
    console.log(`folder ${projectName} exists`);
    return false;
  }
  if (!downloadUrl) {
    downloadUrl = await exports.getLastestRelease(githubUsername, githubProjectName).catch(error => {
      console.log('Error in getting latest release url');
      return false;
    });
  }
  console.log('release file:', downloadUrl);

  // download release file
  let downloadFile = '/tmp/compressed_' + Math.floor(Math.random() * 10000000000);
  await exports.downloadFile(downloadUrl, downloadFile);
  // console.log('downloadFile', downloadFile);

  // decompress release file
  let dest = '/tmp/unzipped_' + Math.floor(Math.random() * 10000000000);
  let downloadFolder = await exports.decompress(downloadFile, dest);

  // find leapbase subfolder
  let subFolders = await exports.getSubFolders(downloadFolder, 'leapbase');
  if (subFolders.length <= 0) {
    console.log('Error in locating leapbase folder in release zip file');
    return false;
  }
  // move lepabase subfolder to projectName folder
  let leapbaseFolder = `${downloadFolder}/${subFolders[0]}`
  // console.log('leapbaseFolder:', leapbaseFolder);
  await move(leapbaseFolder, projectName).catch(error => {
    console.log('Error in moving leapbase folder');
    return false;
  });

  // remove download file and folder
  await remove(downloadFile);
  await remove(downloadFolder);
  return true;
};

exports.addExtension = async function(extensionName, downloadUrl) {
  let githubUsername = 'leapbase';
  let githubProjectName = `leapbase-${extensionName}`;

  if (!exports.isLeapbaseFolder('./')) {
    console.log('current folder does not contain leapbase files');
    return false;
  }
  let extensionFolder = `./site/extension/${extensionName}`;
  if (fs.existsSync(extensionFolder)) {
    console.log(`extension ${extensionName} exists`);
    return false;
  }
  if (!downloadUrl) {
    downloadUrl = await exports.getLastestRelease(githubUsername, githubProjectName).catch(error => {
      console.log('Error in getting latest release url');
      return false;
    });
  }
  console.log('release file:', downloadUrl);

  // download release file
  let downloadFile = '/tmp/compressed_' + Math.floor(Math.random() * 10000000000);
  await exports.downloadFile(downloadUrl, downloadFile);

  // decompress release file
  let dest = '/tmp/unzipped_' + Math.floor(Math.random() * 10000000000);
  let downloadFolder = await exports.decompress(downloadFile, dest);

  // find leapbase subfolder
  let subFolders = await exports.getSubFolders(downloadFolder, 'leapbase');
  if (subFolders.length <= 0) {
    console.log('Error in locating leapbase folder in release zip file');
    return false;
  }
  // move lepabase subfolder to projectName folder
  let leapbaseFolder = `${downloadFolder}/${subFolders[0]}`
  // console.log('leapbaseFolder:', leapbaseFolder);
  await move(leapbaseFolder, extensionFolder).catch(error => {
    console.log('Error in moving extension folder');
    return false;
  });

  // merge extension's package.json to leapbase's package.json as needed
  await exports.mergeExtensionResource(extensionFolder);

  // remove download file and folder
  await remove(downloadFile);
  await remove(downloadFolder);

  // create symlinks for extension
  let symlinkCommand = `bin/create_extension_symlinks ${extensionName}`;
  await exports.runShellCommand(symlinkCommand);

  return true;
};

exports.removeExtension = async function(extensionName) {
  if (!exports.isLeapbaseFolder('./')) {
    console.log('current folder does not contain leapbase files');
    return false;
  }
  let extensionFolder = `./site/extension/${extensionName}`;
  if (!fs.existsSync(extensionFolder)) {
    console.log(`extension ${extensionName} does not exist`);
    return false;
  }

  // create symlinks for extension
  let symlinkCommand = `bin/remove_extension_symlinks ${extensionName}`;
  await exports.runShellCommand(symlinkCommand);

  // remove extension folder
  await remove(extensionFolder);

  return true;
};


exports.listExtension = async function(extensionName) {

  return ['user', 'admin', 'web', 'example'];
};
