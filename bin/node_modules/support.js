'use strict';
const debug = require('debug')('support');
const { readdirSync, existsSync, createWriteStream } = require('fs')
const { move, remove } = require('fs-extra');
const path = require('path');
const { promisify } = require('util');
const axios = require('axios');
const unzip = require('unzipper');
const decompress = require('decompress');

exports.isLeapbaseFolder = async function(path) {
  return true;
};

exports.getLastestRelease = async function(githubUsername, githubProjectName) {
  let zipUrl = '';
  var releaseUrl = `https://api.github.com/repos/${githubUsername}/${githubProjectName}/releases/latest`;
  try {
    const response = await axios.get(releaseUrl);
    zipUrl = response.data && response.data.zipball_url || '';
  } catch (error) {
    console.error(error);
  }
  return zipUrl;
};

exports.downloadUnzip = async function(url, dest) {
  const response = await axios({
    url: url,
    method: 'GET',
    responseType: 'stream'
  });
  const stream = response.data.pipe(unzip.Extract({ path:dest }));
  return new Promise((resolve, reject) => {
    stream.on('close', () => resolve(dest));
    stream.on('error', () => reject);
  });
};

exports.downloadFile = async function(url, filename) {
  const response = await axios({
    url: url,
    method: 'GET',
    responseType: 'stream'
  });
  const writeStream = createWriteStream(filename);
  response.data.pipe(writeStream);
  return new Promise((resolve, reject) => {
    writeStream.on('close', () => resolve(filename));
    writeStream.on('error', () => reject);
  });
};

exports.decompress = async function(filename, extractFolder) {
  await decompress(filename, extractFolder);
  return extractFolder;
};

// find subfolder starting with given prefix value
exports.getSubFolders = async function(path, prefix) {
  let folders = readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
  if (prefix) {
    const regex = new RegExp('^' + prefix);
    folders = folders.filter(name => name.match(regex))
  }
  return folders
};

exports.runShellCommand = async function(command) {
  const exec = promisify(require('child_process').exec);
    const { stdout, stderr } = await exec(command);
    if (stderr) {
      console.error(`error: ${stderr}`);
    }
    return stdout;
}

exports.createProject = async function(projectName, downloadUrl) {
  let githubUsername = 'leapbase';
  let githubProjectName = 'leapbase';
  
  if (existsSync(projectName)) {
    console.log(`folder ${projectName} exists`);
    return false;
  }
  if (!downloadUrl) {
    downloadUrl = await exports.getLastestRelease(githubUsername, githubProjectName).catch(error => {
      console.log('Error in getting latest release url');
      return false;
    });
  }
  console.log('release file:', downloadUrl);
  
  // download release file
  let downloadFile = '/tmp/compressed_' + Math.floor(Math.random() * 10000000000);
  await exports.downloadFile(downloadUrl, downloadFile);
  // console.log('downloadFile', downloadFile);
  
  // decompress release file
  let dest = '/tmp/unzipped_' + Math.floor(Math.random() * 10000000000);
  let downloadFolder = await exports.decompress(downloadFile, dest);
  
  // find leapbase subfolder
  let subFolders = await exports.getSubFolders(downloadFolder, 'leapbase');
  if (subFolders.length <= 0) {
    console.log('Error in locating leapbase folder in release zip file');
    return false;
  }
  // move lepabase subfolder to projectName folder
  let leapbaseFolder = `${downloadFolder}/${subFolders[0]}`
  // console.log('leapbaseFolder:', leapbaseFolder);
  await move(leapbaseFolder, projectName).catch(error => {
    console.log('Error in moving leapbase folder');
    return false;
  });
  
  // remove download file and folder
  await remove(downloadFile);
  await remove(downloadFolder);
  return true;
};

exports.addExtension = async function(extensionName, downloadUrl) {
  let githubUsername = 'leapbase';
  let githubProjectName = `leapbase-${extensionName}`;
  
  if (!exports.isLeapbaseFolder('./')) {
    console.log('current folder does not contain leapbase files');
    return false;
  }
  let extensionFolder = `./site/extension/${extensionName}`;
  if (existsSync(extensionFolder)) {
    console.log(`extension ${extensionName} exists`);
    return false;
  }
  if (!downloadUrl) {
    downloadUrl = await exports.getLastestRelease(githubUsername, githubProjectName).catch(error => {
      console.log('Error in getting latest release url');
      return false;
    });
  }
  console.log('release file:', downloadUrl);
  
  // download release file
  let downloadFile = '/tmp/compressed_' + Math.floor(Math.random() * 10000000000);
  await exports.downloadFile(downloadUrl, downloadFile);
  
  // decompress release file
  let dest = '/tmp/unzipped_' + Math.floor(Math.random() * 10000000000);
  let downloadFolder = await exports.decompress(downloadFile, dest);
  
  // find leapbase subfolder
  let subFolders = await exports.getSubFolders(downloadFolder, 'leapbase');
  if (subFolders.length <= 0) {
    console.log('Error in locating leapbase folder in release zip file');
    return false;
  }
  // move lepabase subfolder to projectName folder
  let leapbaseFolder = `${downloadFolder}/${subFolders[0]}`
  // console.log('leapbaseFolder:', leapbaseFolder);
  await move(leapbaseFolder, extensionFolder).catch(error => {
    console.log('Error in moving extension folder');
    return false;
  });
  
  // remove download file and folder
  await remove(downloadFile);
  await remove(downloadFolder);
  
  // create symlinks for extension
  let symlinkCommand = `bin/create_extension_symlinks ${extensionName}`;
  await exports.runShellCommand(symlinkCommand);
  
  return true;
};

